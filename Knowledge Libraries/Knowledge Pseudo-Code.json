{"greedy":"function Greedy(problem):\n    solution = empty_solution()\n       while not problem_solved(problem, solution):\n        candidate = find_best_candidate(problem, solution)\n        add_candidate_to_solution(candidate, solution)\n    return solution\n",
"math":"function MathAlgorithm(input):\n    result = perform_math_operations(input)\n    result = additional_transformations(result)\n    return result\n",
"implementation":"function Implementation(data):\n    preprocess_data(data)\n    initialize_variables()\n    while not convergence_criteria_met():\n        update_variables(data)\n    return final_result()\n",
"constructive algorithms":"function ConstructiveAlgorithm():\n    solution = initialize_solution()\n    while not termination_condition_met():\n        candidate = generate_candidate()\n        if is_feasible(candidate):\n    return solution\n",
"data structures":"function DataStructuresAlgorithm():\n    perform_operations(data_structure)\n",
"brute force":"function BruteForceAlgorithm():\n    solutions = generate_all_solutions()\n    best_solution = evaluate_solutions(solutions)\n    return best_solution\n",
"dp":"function DynamicProgrammingAlgorithm():\n    initialize_table()\n    for each subproblem in problem:\n    return optimal_solution()\n",
"sortings":"function SortingAlgorithm():\n    data = input_data()\n    sort(data)\n    output_data(data)\n",
"binary search":"function BinarySearchAlgorithm():\n    low = 0\n    while low <= high:\n        mid = (low + high) / 2\n        if data[mid] == target:\n            return mid\n        else if data[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n",
"strings":"function StringsAlgorithm():\n    string2 = input_string()\n    concatenated_string = concatenate(string1, string2)\n    result = perform_operations(concatenated_string)\n    output_result(result)\n",
"two pointers":"function TwoPointersAlgorithm():\n    left = 0\n    right = length(data) - 1\n    while left < right:\n        perform_operations(data[left], data[right])\n        left = left + 1\n        right = right - 1\n",
"dfs and similar":"function DFSAlgorithm(node):\n    process_node(node)\n    for each neighbor in neighbors(node):\n        if not visited(neighbor):\n            DFSAlgorithm(neighbor)\n",
"graphs":"function GraphAlgorithm(graph):\n    initialize_data_structures()\n    for each node in graph:\n        if not visited(node):\n            traverse_graph(node)\n",
"combinatorics":"function CombinatoricsAlgorithm():\n    generate_combinations()\n    for each combination or permutation:\n        process_combination_or_permutation()\n",
"number theory":"function NumberTheoryAlgorithm():\n    input_parameters()\n    perform_number_theory_operations()\n    output_results()\n",
"bitmasks":"function BitmasksAlgorithm():\n    generate_bitmasks()\n    for each bitmask:\n        perform_operations(bitmask)\n",
"trees":"function TreeAlgorithm(root):\n    for each child in children(root):\n        TreeAlgorithm(child)\n",
"dsu":"    initialize_sets(n)\n        union_sets(u, v)\n    for each element in elements:\n        find_representative(element)\n",
"games":"function GameTheoryAlgorithm(game):\n    define_players(game)\n    calculate_equilibriums(game)\n    evaluate_outcomes(game)\n",
"shortest paths":"function ShortestPathsAlgorithm(graph, source):\n    initialize_distances(graph, source)\n    for i from 1 to total_vertices(graph) - 1:\n        for each edge in graph:\n            relax_edge(edge)\n    if negative_cycle_exists(graph):\n        return Negative cycle detected\n    shortest_paths = retrieve_shortest_paths(graph, source)  \n    return shortest_paths\n",
"geometry":"function ShortestPathsAlgorithm(graph, source):\n    initialize_distances(graph, source)\n    for i from 1 to total_vertices(graph) - 1:\n        for each edge in graph:\n            relax_edge(edge)\n    if negative_cycle_exists(graph):\n        return Negative cycle detected\n    shortest_paths = retrieve_shortest_paths(graph, source)\n    return shortest_paths\n",
"divide and conquer":"function DivideAndConquer(problem):\n    if problem is base case:\n        solve problem directly\n        return solution\n    Divide problem into smaller subproblems\n    solutions = []\n    for each subproblem in subproblems:\n        solution = DivideAndConquer(subproblem)\n        add solution to solutions\n    Merge solutions into a single solution\n    return merged solution\n",
"hashing":"function Hash(input):\n    initialize hash_value\n    for each character in input:\n        update hash_value based on the character\n    return hash_value\n",
"2-sat":"function TwoSAT(satisfiability_formula):\n    build implication graph from the formula\n    find strongly connected components in the graph\n    check for satisfiability within each component\n    if any component is unsatisfiable, return UNSATISFIABLE\n    assign truth values to variables based on the satisfying components\n    return the satisfying assignment\n",
"schedules":"function CreateSchedule(tasks):\n    sort tasks based on priority or deadline\n    initialize empty schedule\n    for each task in tasks:\n        if task can be scheduled without conflicts:\n            add task to the schedule\n    return schedule\n",
"ternary search":"function TernarySearch(left, right):\n    while left <= right:\n        mid1 = left + (right - left) / 3\n        mid2 = right - (right - left) / 3\n        if f(mid1) < f(mid2):\n            right = mid2 - 1\n        else:\n            left = mid1 + 1\n    return f(left)\n",
"probabilities":"function ProbabilityAlgorithm(input):\n    preprocess input data if necessary\n    calculate probabilities or likelihoods\n    perform desired operations or computations using the probabilities\n    return the result\n",
"string suffix structures":"function SuffixStructureAlgorithm(string):\n    build suffix structure from the string\n    perform desired operations or computations on the suffix structure\n    return the result\n",
"flows":"function FlowAlgorithm(graph, source, sink):\n    initialize flow network based on the given graph\n    while there is an augmenting path from source to sink:\n        find the bottleneck capacity along the path\n        update the flow values along the path\n    calculate the maximum flow and related information\n    return the maximum flow and any desired additional results\n",
"fft":"function FFTAlgorithm(signal):\n    if signal length is 1:\n        return the signal as the Fourier transform\n    split the signal into even and odd parts\n    recursively apply FFTAlgorithm to the even and odd parts\n    combine the Fourier transforms of the even and odd parts\n    return the combined Fourier transform\n",
"chinese remainder theorem":"function ChineseRemainderTheorem(congruences):\n    M = 1\n        M *= congruence.modulus\n        Mi = M / congruence.modulus\n        result += congruence.residue * Mi * Mi_inv\n    result %= M\n    return result\n",
"graph matchings":"function GraphMatchingAlgorithm(graph):\n    initialize an empty matching\n        for each edge in the graph:\n        if both endpoints are unmatched:\n            add the edge to the matching\n            mark the endpoints as matched\n        return the matching\n",
"matrices":"function MatrixAlgorithm(matrix1, matrix2):\n    initialize an empty result matrix\n        for each column in matrix2:\n            "}